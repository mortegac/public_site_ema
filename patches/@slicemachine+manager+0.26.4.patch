diff --git a/node_modules/@slicemachine/manager/dist/managers/customTypes/CustomTypesManager.cjs b/node_modules/@slicemachine/manager/dist/managers/customTypes/CustomTypesManager.cjs
index b9bcec3..eaff98f 100644
--- a/node_modules/@slicemachine/manager/dist/managers/customTypes/CustomTypesManager.cjs
+++ b/node_modules/@slicemachine/manager/dist/managers/customTypes/CustomTypesManager.cjs
@@ -19,7 +19,14 @@ const os = require("node:os");
 const crypto = require("node:crypto");
 const path = require("node:path");
 const fs = require("node:fs/promises");
-const claudeAgentSdk = require("@anthropic-ai/claude-agent-sdk");
+// Dynamic import for ESM module - loaded lazily in inferSlice method
+let claudeAgentSdk;
+async function loadClaudeAgentSdk() {
+  if (!claudeAgentSdk) {
+    claudeAgentSdk = await import("@anthropic-ai/claude-agent-sdk");
+  }
+  return claudeAgentSdk;
+}
 function _interopNamespaceDefault(e) {
   const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
   if (e) {
@@ -539,7 +546,8 @@ FINAL REMINDERS:
             source,
             llmProxyUrl
           });
-          const queries = claudeAgentSdk.query({
+          const claudeAgentSdkModule = await loadClaudeAgentSdk();
+          const queries = claudeAgentSdkModule.query({
             prompt,
             options: {
               cwd,
@@ -651,7 +659,8 @@ x-prismic-repository: ${repository}
         return InferSliceResponse.parse(json);
       }
     } catch (error) {
-      if (error instanceof claudeAgentSdk.AbortError || error instanceof Error && error.name === "AbortError") {
+      const claudeAgentSdkModule = await loadClaudeAgentSdk().catch(() => null);
+      if (claudeAgentSdkModule && (error instanceof claudeAgentSdkModule.AbortError || error instanceof Error && error.name === "AbortError")) {
         console.warn(`inferSlice (${source}) request ${requestId} was aborted`);
         throw new errors.InferSliceAbortError();
       }
diff --git a/node_modules/@slicemachine/manager/dist/managers/customTypes/CustomTypesManager.cjs.backup b/node_modules/@slicemachine/manager/dist/managers/customTypes/CustomTypesManager.cjs.backup
new file mode 100644
index 0000000..b9bcec3
--- /dev/null
+++ b/node_modules/@slicemachine/manager/dist/managers/customTypes/CustomTypesManager.cjs.backup
@@ -0,0 +1,891 @@
+"use strict";
+var __defProp = Object.defineProperty;
+var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
+Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
+const t = require("io-ts");
+const prismicCustomTypesClient = require("@prismicio/custom-types-client");
+const customtypes = require("@prismicio/types-internal/lib/customtypes");
+const index = require('./../../_node_modules/zod/lib/index.cjs');
+const assertPluginsInitialized = require("../../lib/assertPluginsInitialized.cjs");
+const decodeHookResult = require("../../lib/decodeHookResult.cjs");
+const fetch = require("../../lib/fetch.cjs");
+const API_ENDPOINTS = require("../../constants/API_ENDPOINTS.cjs");
+const SLICE_MACHINE_USER_AGENT = require("../../constants/SLICE_MACHINE_USER_AGENT.cjs");
+const errors = require("../../errors.cjs");
+const BaseManager = require("../BaseManager.cjs");
+const node_fs = require("node:fs");
+const os = require("node:os");
+const crypto = require("node:crypto");
+const path = require("node:path");
+const fs = require("node:fs/promises");
+const claudeAgentSdk = require("@anthropic-ai/claude-agent-sdk");
+function _interopNamespaceDefault(e) {
+  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
+  if (e) {
+    for (const k in e) {
+      if (k !== "default") {
+        const d = Object.getOwnPropertyDescriptor(e, k);
+        Object.defineProperty(n, k, d.get ? d : {
+          enumerable: true,
+          get: () => e[k]
+        });
+      }
+    }
+  }
+  n.default = e;
+  return Object.freeze(n);
+}
+const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
+const prismicCustomTypesClient__namespace = /* @__PURE__ */ _interopNamespaceDefault(prismicCustomTypesClient);
+class CustomTypesManager extends BaseManager.BaseManager {
+  constructor() {
+    super(...arguments);
+    __publicField(this, "inferSliceAbortControllers", /* @__PURE__ */ new Map());
+    // https://code.claude.com/docs/en/settings#environment-variables
+    __publicField(this, "claudeExcludePatterns", [
+      "ANTHROPIC_",
+      "CLAUDE_",
+      "MCP_",
+      "VERTEX_",
+      "DISABLE_",
+      "BASH_",
+      "AWS_",
+      "SLASH_COMMAND_",
+      "NO_PROXY",
+      "HTTP_PROXY",
+      "HTTPS_PROXY",
+      "HTTP_MAX_REDIRECTS",
+      "MAX_THINKING_TOKENS",
+      "USE_BUILTIN_RIPGREP"
+    ]);
+  }
+  async readCustomTypeLibrary() {
+    var _a;
+    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type-library:read", void 0);
+    const { data, errors: errors2 } = decodeHookResult.decodeHookResult(t__namespace.type({
+      ids: t__namespace.array(t__namespace.string)
+    }), hookResult);
+    return {
+      ids: ((_a = data[0]) == null ? void 0 : _a.ids) || [],
+      errors: errors2
+    };
+  }
+  async readAllCustomTypes(args) {
+    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+    const res = {
+      models: [],
+      errors: []
+    };
+    const { ids, errors: errors2 } = await this.readCustomTypeLibrary();
+    res.errors = [...res.errors, ...errors2];
+    if (ids) {
+      for (const id of ids) {
+        const { model, errors: errors22 } = await this.readCustomType({ id });
+        res.errors = [...res.errors, ...errors22];
+        if (model && (!args || args.format === model.format)) {
+          res.models.push({ model });
+        }
+      }
+    }
+    return res;
+  }
+  async createCustomType(args) {
+    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:create", args);
+    return {
+      errors: hookResult.errors
+    };
+  }
+  async readCustomType(args) {
+    var _a;
+    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:read", args);
+    const { data, errors: errors2 } = decodeHookResult.decodeHookResult(t__namespace.type({
+      model: customtypes.CustomType
+    }), hookResult);
+    return {
+      model: (_a = data[0]) == null ? void 0 : _a.model,
+      errors: errors2
+    };
+  }
+  /**
+   * Update the Content Relationship API IDs for all existing custom types and
+   * slices. The change is determined by properties inside the `updateMeta`
+   * property.
+   */
+  async updateContentRelationships(args) {
+    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+    const { model, previousPath: previousFieldPath, newPath: newFieldPath } = args;
+    if (previousFieldPath.join(".") !== newFieldPath.join(".")) {
+      const { id: ctId } = model;
+      const previousPath = [ctId, ...previousFieldPath];
+      const newPath = [ctId, ...newFieldPath];
+      const crUpdates = [];
+      const customTypes = await this.readAllCustomTypes();
+      updateCustomTypeContentRelationships({
+        models: customTypes.models,
+        onUpdate: ({ previousModel, model: updatedModel }) => {
+          var _a;
+          assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+          crUpdates.push({
+            updatePromise: (_a = this.sliceMachinePluginRunner) == null ? void 0 : _a.callHook("custom-type:update", { model: updatedModel }),
+            rollback: () => {
+              var _a2;
+              (_a2 = this.sliceMachinePluginRunner) == null ? void 0 : _a2.callHook("custom-type:update", {
+                model: previousModel
+              });
+            }
+          });
+        },
+        previousPath,
+        newPath
+      });
+      const { libraries } = await this.slices.readAllSliceLibraries();
+      for (const library of libraries) {
+        const slices = await this.slices.readAllSlicesForLibrary({
+          libraryID: library.libraryID
+        });
+        updateSharedSliceContentRelationships({
+          models: slices.models,
+          onUpdate: ({ previousModel, model: updatedModel }) => {
+            var _a;
+            assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+            crUpdates.push({
+              updatePromise: (_a = this.sliceMachinePluginRunner) == null ? void 0 : _a.callHook("slice:update", { libraryID: library.libraryID, model: updatedModel }),
+              rollback: () => {
+                var _a2;
+                (_a2 = this.sliceMachinePluginRunner) == null ? void 0 : _a2.callHook("slice:update", {
+                  libraryID: library.libraryID,
+                  model: previousModel
+                });
+              }
+            });
+          },
+          previousPath,
+          newPath
+        });
+      }
+      const crUpdatesResult = await Promise.all(crUpdates.map((update) => update.updatePromise));
+      if (crUpdatesResult.some((result) => result.errors.length > 0)) {
+        return {
+          errors: crUpdatesResult.flatMap((result) => result.errors),
+          rollback: async () => {
+            await Promise.all(crUpdates.map((update) => update.rollback()));
+          }
+        };
+      }
+    }
+    return { errors: [] };
+  }
+  async updateCustomType(args) {
+    var _a, _b;
+    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+    const { model } = args;
+    const { fieldIdChanged } = args.updateMeta ?? {};
+    let previousCustomType;
+    if (fieldIdChanged) {
+      const customTypeRead = await this.readCustomType({ id: model.id });
+      if (customTypeRead.errors.length > 0) {
+        return { errors: customTypeRead.errors };
+      }
+      if (!customTypeRead.model) {
+        throw new Error(`readCustomType succeeded reading custom type ${model.id} but model is undefined.`);
+      }
+      previousCustomType = customTypeRead.model;
+    }
+    const customTypeUpdateResult = await this.sliceMachinePluginRunner.callHook("custom-type:update", { model });
+    if (customTypeUpdateResult.errors.length > 0) {
+      return { errors: customTypeUpdateResult.errors };
+    }
+    if (previousCustomType && fieldIdChanged) {
+      const crUpdateResult = await this.updateContentRelationships({
+        ...fieldIdChanged,
+        model: previousCustomType
+      });
+      if (crUpdateResult.errors.length > 0) {
+        await ((_a = this.sliceMachinePluginRunner) == null ? void 0 : _a.callHook("custom-type:update", {
+          model: previousCustomType
+        }));
+        await ((_b = crUpdateResult.rollback) == null ? void 0 : _b.call(crUpdateResult));
+        return { errors: crUpdateResult.errors };
+      }
+    }
+    return { errors: [] };
+  }
+  async renameCustomType(args) {
+    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:rename", args);
+    return {
+      errors: hookResult.errors
+    };
+  }
+  async deleteCustomType(args) {
+    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+    const { model, errors: readCustomTypeErrors } = await this.readCustomType({
+      id: args.id
+    });
+    if (model) {
+      const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:delete", { model });
+      return {
+        errors: hookResult.errors
+      };
+    } else {
+      return {
+        errors: readCustomTypeErrors
+      };
+    }
+  }
+  async pushCustomType(args) {
+    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+    const authenticationToken = await this.user.getAuthenticationToken();
+    const repositoryName = await this.project.getResolvedRepositoryName();
+    const { model } = await this.readCustomType({ id: args.id });
+    if (model) {
+      const client = prismicCustomTypesClient__namespace.createClient({
+        endpoint: API_ENDPOINTS.API_ENDPOINTS.PrismicModels,
+        repositoryName,
+        token: authenticationToken,
+        fetch: fetch.default,
+        fetchOptions: {
+          headers: {
+            "User-Agent": args.userAgent || SLICE_MACHINE_USER_AGENT.SLICE_MACHINE_USER_AGENT
+          }
+        }
+      });
+      try {
+        await client.getCustomTypeByID(args.id);
+        await client.updateCustomType(model);
+      } catch (error) {
+        if (error instanceof prismicCustomTypesClient__namespace.NotFoundError) {
+          await client.insertCustomType(model);
+        } else if (error instanceof prismicCustomTypesClient__namespace.ForbiddenError) {
+          throw new errors.UnauthorizedError("You do not have access to push types to this Prismic repository.", {
+            cause: error
+          });
+        } else {
+          throw error;
+        }
+      }
+    }
+  }
+  // TODO: Remove
+  async readCustomTypeMocksConfig(args) {
+    var _a;
+    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:asset:read", {
+      customTypeID: args.customTypeID,
+      assetID: "mocks.config.json"
+    });
+    const data = (_a = hookResult.data[0]) == null ? void 0 : _a.data;
+    if (data) {
+      return {
+        mocksConfig: JSON.parse(data.toString()),
+        errors: hookResult.errors
+      };
+    } else {
+      return {
+        mocksConfig: void 0,
+        errors: hookResult.errors
+      };
+    }
+  }
+  // TODO: Remove
+  async updateCustomTypeMocksConfig(args) {
+    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
+    const hookResult = await this.sliceMachinePluginRunner.callHook("custom-type:asset:update", {
+      customTypeID: args.customTypeID,
+      asset: {
+        id: "mocks.config.json",
+        data: Buffer.from(JSON.stringify(args.mocksConfig, null, "	"))
+      }
+    });
+    return {
+      errors: hookResult.errors
+    };
+  }
+  async fetchRemoteCustomTypes() {
+    const authenticationToken = await this.user.getAuthenticationToken();
+    const repositoryName = await this.project.getResolvedRepositoryName();
+    const client = prismicCustomTypesClient__namespace.createClient({
+      endpoint: API_ENDPOINTS.API_ENDPOINTS.PrismicModels,
+      repositoryName,
+      token: authenticationToken,
+      fetch: fetch.default,
+      fetchOptions: {
+        headers: {
+          "User-Agent": SLICE_MACHINE_USER_AGENT.SLICE_MACHINE_USER_AGENT
+        }
+      }
+    });
+    return await client.getAllCustomTypes();
+  }
+  async inferSlice(args) {
+    var _a;
+    const { source, imageUrl, requestId } = args;
+    const authToken = await this.user.getAuthenticationToken();
+    const repository = await this.project.getResolvedRepositoryName();
+    const abortController = new AbortController();
+    const timeoutId = setTimeout(() => {
+      if (abortController && !(abortController == null ? void 0 : abortController.signal.aborted)) {
+        abortController == null ? void 0 : abortController.abort();
+        console.warn(`inferSlice (${source}) request ${requestId} timed out after 5 minutes`);
+      }
+    }, 5 * 60 * 1e3);
+    abortController.signal.addEventListener("abort", () => {
+      clearTimeout(timeoutId);
+      console.warn(`inferSlice (${source}) request ${requestId} was aborted`);
+    });
+    this.inferSliceAbortControllers.set(requestId, abortController);
+    console.info(`inferSlice (${source}) started for request ${requestId}`);
+    const startTime = Date.now();
+    const claudeErrors = [];
+    try {
+      if (source === "figma") {
+        const { libraryID } = args;
+        const exp = await this.telemetry.getExperimentVariant("llm-proxy-access");
+        if ((exp == null ? void 0 : exp.value) !== "on") {
+          throw new Error("User does not have access to the LLM proxy.");
+        }
+        const { llmProxyUrl } = index.default.object({ llmProxyUrl: index.default.string().url() }).parse(exp.payload);
+        let tmpDir;
+        try {
+          const config = await this.project.getSliceMachineConfig();
+          let framework;
+          if (config.adapter === "@slicemachine/adapter-next") {
+            framework = { type: "nextjs", label: "Next.js (React)" };
+          } else if (config.adapter === "@slicemachine/adapter-nuxt" || config.adapter === "@slicemachine/adapter-nuxt2") {
+            framework = { type: "nuxt", label: "Nuxt (Vue)" };
+          } else if (config.adapter === "@slicemachine/adapter-sveltekit") {
+            framework = { type: "sveltekit", label: "SvelteKit (Svelte)" };
+          }
+          if (!framework) {
+            throw new Error("Could not determine framework from Slice Machine config.");
+          }
+          const projectRoot = await this.project.getRoot();
+          const libraryAbsPath = path.join(projectRoot, libraryID);
+          const cwd = libraryAbsPath;
+          tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), "slice-machine-infer-slice-tmp-"));
+          const tmpImageAbsPath = path.join(tmpDir, `${crypto.randomUUID()}.png`);
+          const response = await fetch.default(imageUrl);
+          if (!response.ok) {
+            throw new Error(`Failed to download image: ${response.status} ${response.statusText}`);
+          }
+          await fs.writeFile(tmpImageAbsPath, Buffer.from(await response.arrayBuffer()));
+          const otherSlices = (await Promise.all((await fs.readdir(libraryAbsPath, { withFileTypes: true })).flatMap(async (path$1) => {
+            try {
+              if (!path$1.isDirectory()) {
+                throw new Error("Not a directory");
+              }
+              const absPath = path.join(libraryAbsPath, path$1.name);
+              const modelAbsPath = path.join(absPath, "model.json");
+              if (!node_fs.existsSync(modelAbsPath)) {
+                throw new Error("Model file not found");
+              }
+              const decoded = customtypes.SharedSlice.decode(JSON.parse(await fs.readFile(modelAbsPath, "utf-8")));
+              if (decoded._tag === "Left") {
+                throw new Error("Invalid model file");
+              }
+              return [
+                {
+                  absPath,
+                  relPath: path.relative(cwd, absPath),
+                  name: decoded.right.name
+                }
+              ];
+            } catch {
+              return [];
+            }
+          }))).flat();
+          const prompt = `CRITICAL INSTRUCTIONS - READ FIRST:
+- You MUST start immediately with Step 1.1. DO NOT read, analyze, or explore any project files first.
+- Work step-by-step through the numbered tasks below.
+- DO NOT present any summary, explanation, or completion message after finishing.
+- DO NOT create TODO lists while performing tasks.
+- Keep responses minimal - only show necessary tool calls and brief progress notes.
+
+# CONTEXT 
+
+The user wants to build a new Prismic Slice based on a design image they provided.
+Your goal is to analyze the design image and generate the JSON model data and boilerplate code for the slice following Prismic requirements.
+
+You will work under the slice library at <slice_library_directory_path>, where all the slices are stored.
+
+# AVAILABLE RESOURCES
+
+<framework>
+${framework.label}
+</framework>
+
+<design_image_path>
+${tmpImageAbsPath}
+</design_image_path>
+
+<slice_library_directory_path>
+${libraryAbsPath}
+</slice_library_directory_path>
+
+<disallowed_slice_names>
+${otherSlices.map((slice) => `- ${slice.name}`).join("\n")}
+</disallowed_slice_names>
+
+# AVAILABLE TOOLS
+
+You have access to specialized Prismic MCP tools for this task:
+
+<tool name="mcp__prismic__how_to_model_slice">
+<description>
+Provides detailed guidance on creating Prismic slice models, including field types, naming conventions, and best practices.
+</description>
+<when_to_use>
+Call this tool in Step 2.1 to learn how to structure the slice model data for the design you analysed.
+</when_to_use>
+</tool>
+
+<tool name="mcp__prismic__how_to_code_slice">
+<description>
+Provides guidance on implementing Prismic slice components, including how to use Prismic field components, props structure, and best practices.
+</description>
+<when_to_use>
+Call this tool in Step 2.1 to learn how to properly structure the slice component with Prismic fields.
+</when_to_use>
+</tool>
+
+<tool name="mcp__prismic__save_slice_data">
+<description>
+Validates and saves the slice model data to model.json. This is the ONLY way to create the model file.
+</description>
+<when_to_use>
+Call this tool in Step 2.3 after you have built the complete slice model structure in memory.
+</when_to_use>
+</tool>
+
+# TASK REQUIREMENTS
+
+## Step 1: Gather information from the design image
+1.1. Analyse the design image at <design_image_path>.
+1.2. Identify all elements in the image that should be dynamically editable (e.g., headings, paragraphs, images, links, buttons, etc.).
+1.3. Come up with a UNIQUE name for the new slice based on the content of the image, DO NOT use any of the names in <disallowed_slice_names>.
+
+## Step 2: Model the Prismic slice
+2.1. Call mcp__prismic__how_to_model_slice to learn how to structure the model for this design.
+2.2. Build the complete slice JSON model data in memory based on the guidance received and the information extracted from the image.
+2.3. Call mcp__prismic__save_slice_data to save the model (DO NOT manually write model.json) in the slice library at <slice_library_directory_path>.
+
+## Step 3: Code a boilerplate slice component based on the model
+3.1. Call mcp__prismic__how_to_code_slice to learn how to properly structure the slice component with Prismic fields.
+3.2. Update the slice component code at <slice_library_directory_path>/index.*, replacing the placeholder code with boilerplate code with the following requirements:
+- Must NOT be based on existing slices or components from the codebase.
+- Must render all the Prismic components to display the fields of the slice model created at <slice_model_path>.
+- Must be a valid ${framework.label} component.
+- Must NOT have any styling/CSS. No inlines styles or classNames. Just the skeleton component structure.
+- Must NOT use any other custom component or functions from the user's codebase.
+- Avoid creating unnecessary wrapper elements, like if they only wrap a single component (e.g., <div><PrismicRichText /></div>).
+
+## Step 4: Present the newly created slice path
+4.1. Present the path to the newly created slice in the following format: <new_slice_path>${libraryAbsPath}/MyNewSlice</new_slice_path>.
+- "MyNewSlice" must be the name of the directory of the newly created slice.
+
+# EXAMPLE OF CORRECT EXECUTION
+
+<example>
+Assistant: Step 1.1: Analysing design image...
+[reads <design_image_path>]
+
+Step 1.2: Identifying editable content elements...
+[identifies: title field, description field, buttonText field, buttonLink field, backgroundImage field]
+
+Step 1.3: Listing slice directories under <slice_library_directory_path>...
+[lists slice directories: Hero, Hero2, Hero3]
+
+Step 1.4: Coming up with a unique name for the new slice...
+[comes up with a unique name for the new slice: Hero4]
+
+Step 2.1: Getting Prismic modeling guidance...
+[calls mcp__prismic__how_to_model_slice]
+
+Step 2.2: Building slice model based on guidance and the information extracted...
+[creates model with title field, description field, buttonText field, buttonLink field, backgroundImage field]
+
+Step 2.3: Saving slice model...
+[calls mcp__prismic__save_slice_data]
+
+Step 3.1: Learning Prismic slice coding requirements...
+[calls mcp__prismic__how_to_code_slice]
+
+Step 3.2: Coding boilerplate slice component based on the model...
+[updates component with Prismic field components, no styling, no other components]
+
+Step 4.1: Presenting the path to the newly created slice...
+[presents <new_slice_path>${path.join(libraryAbsPath, "MyNewSlice")}</new_slice_path>]
+
+# DELIVERABLES
+- Slice model saved to <slice_library_directory_path>/model.json using mcp__prismic__save_slice_data
+- Slice component at <slice_library_directory_path>/index.* updated with boilerplate code
+- New slice path presented in the format mentioned in Step 3.1
+
+YOU ARE NOT FINISHED UNTIL YOU HAVE THESE DELIVERABLES.
+
+---
+
+FINAL REMINDERS:
+- You MUST use mcp__prismic__save_slice_data to save the model
+- You MUST call mcp__prismic__how_to_code_slice in Step 3.1
+- DO NOT ATTEMPT TO BUILD THE APPLICATION
+- START IMMEDIATELY WITH STEP 1.1 - NO PRELIMINARY ANALYSIS`;
+          void this.telemetry.track({
+            event: "slice-generation:started",
+            source,
+            llmProxyUrl
+          });
+          const queries = claudeAgentSdk.query({
+            prompt,
+            options: {
+              cwd,
+              stderr: (error) => {
+                if (!error.startsWith("Spawning Claude Code process")) {
+                  claudeErrors.push(error);
+                  console.error(`inferSlice - stderr for request ${requestId}:`, error);
+                }
+              },
+              model: "claude-haiku-4-5",
+              permissionMode: "acceptEdits",
+              allowedTools: [
+                `Bash(${cwd})`,
+                "Read",
+                "Grep",
+                "Glob",
+                "Write",
+                "Edit",
+                "MultiEdit",
+                "FileSearch",
+                "mcp__prismic__how_to_model_slice",
+                "mcp__prismic__how_to_code_slice",
+                "mcp__prismic__save_slice_data"
+              ],
+              disallowedTools: [
+                `Edit(**/model.json)`,
+                `Write(**/model.json)`,
+                "Edit(**/mocks.json)",
+                "Write(**/mocks.json)",
+                ...otherSlices.flatMap((slice) => [
+                  `Write(${slice.relPath})`,
+                  `Edit(${slice.relPath})`,
+                  `MultiEdit(${slice.relPath})`
+                ])
+              ],
+              env: {
+                ...this.sanitizeClaudeEnv(process.env),
+                ANTHROPIC_BASE_URL: llmProxyUrl,
+                ANTHROPIC_CUSTOM_HEADERS: `x-prismic-token: ${authToken}
+x-prismic-repository: ${repository}
+`
+              },
+              mcpServers: {
+                prismic: {
+                  type: "stdio",
+                  command: "npx",
+                  // keep using the latest patch version
+                  args: ["-y", "@prismicio/mcp-server@0.0"]
+                }
+              },
+              abortController
+            }
+          });
+          let newSliceAbsPath;
+          for await (const query of queries) {
+            switch (query.type) {
+              case "result":
+                switch (query.subtype) {
+                  case "success":
+                    if (!query.is_error) {
+                      newSliceAbsPath = (_a = query.result.match(/<new_slice_path>(.*)<\/new_slice_path>/s)) == null ? void 0 : _a[1];
+                    } else {
+                      claudeErrors.push(query.result);
+                    }
+                    break;
+                  case "error_during_execution":
+                  case "error_max_budget_usd":
+                  case "error_max_turns":
+                    claudeErrors.push(...query.errors);
+                    console.error(`inferSlice - result query error for request ${requestId}}:`, query.errors);
+                    break;
+                }
+                break;
+            }
+          }
+          if (!newSliceAbsPath) {
+            throw new Error("Could not find path for the newly created slice.");
+          }
+          const model = await fs.readFile(path.join(newSliceAbsPath, "model.json"), "utf8");
+          if (!model) {
+            throw new Error("Could not find model for the newly created slice.");
+          }
+          await fs.copyFile(tmpImageAbsPath, path.join(newSliceAbsPath, "screenshot-default.png"));
+          try {
+            await fs.rm(tmpImageAbsPath);
+          } catch (error) {
+            console.warn(`inferSlice - Failed to delete temporary slice screenshot at ${tmpImageAbsPath}`, error);
+          }
+          return InferSliceResponse.parse({ slice: JSON.parse(model) });
+        } finally {
+          if (tmpDir && node_fs.existsSync(tmpDir)) {
+            await fs.rm(tmpDir, { recursive: true });
+          }
+        }
+      } else {
+        const searchParams = new URLSearchParams({ repository });
+        const url = new URL("./slices/infer", API_ENDPOINTS.API_ENDPOINTS.CustomTypeService);
+        url.search = searchParams.toString();
+        const response = await fetch.default(url.toString(), {
+          method: "POST",
+          headers: { Authorization: `Bearer ${authToken}` },
+          body: JSON.stringify({ imageUrl }),
+          signal: abortController == null ? void 0 : abortController.signal
+        });
+        if (!response.ok) {
+          throw new Error(`Failed to infer slice: ${response.statusText}`);
+        }
+        const json = await response.json();
+        return InferSliceResponse.parse(json);
+      }
+    } catch (error) {
+      if (error instanceof claudeAgentSdk.AbortError || error instanceof Error && error.name === "AbortError") {
+        console.warn(`inferSlice (${source}) request ${requestId} was aborted`);
+        throw new errors.InferSliceAbortError();
+      }
+      console.error(`inferSlice (${source}) failed for request ${requestId}`, error);
+      throw new Error(`inferSlice encountered errors`, {
+        cause: {
+          error,
+          ...claudeErrors.length > 0 ? { claudeErrors } : {},
+          args
+        }
+      });
+    } finally {
+      this.inferSliceAbortControllers.delete(requestId);
+      clearTimeout(timeoutId);
+      const elapsedTimeSeconds = (Date.now() - startTime) / 1e3;
+      console.info(`inferSlice took ${elapsedTimeSeconds}s for request ${requestId}`);
+    }
+  }
+  sanitizeClaudeEnv(env) {
+    return Object.fromEntries(Object.entries(env).filter(([key, value]) => {
+      return value !== void 0 && !this.claudeExcludePatterns.some((pattern) => key.startsWith(pattern));
+    }));
+  }
+  cancelInferSlice(args) {
+    const { requestId } = args;
+    const abortController = this.inferSliceAbortControllers.get(requestId);
+    if (abortController) {
+      abortController.abort();
+      this.inferSliceAbortControllers.delete(requestId);
+      return { cancelled: true };
+    }
+    return { cancelled: false };
+  }
+}
+const InferSliceResponse = index.default.object({
+  slice: index.default.custom().transform((value, ctx) => {
+    const result = customtypes.SharedSlice.decode(value);
+    if (result._tag === "Right") {
+      return result.right;
+    }
+    ctx.addIssue({
+      code: index.default.ZodIssueCode.custom,
+      message: `Invalid shared slice: ${JSON.stringify(value, null, 2)}`
+    });
+    return index.default.NEVER;
+  }),
+  langSmithUrl: index.default.string().url().optional()
+});
+function updateCRCustomType(args) {
+  const previousPath = getPathIds(args.previousPath);
+  const newPath = getPathIds(args.newPath);
+  if (!previousPath.customTypeId || !newPath.customTypeId) {
+    throw new Error(`Could not find a customtype id in previousPath (${args.previousPath.join(".")}) and/or newPath (${args.newPath.join(".")}), which should not be possible.`);
+  }
+  if (!previousPath.fieldId || !newPath.fieldId) {
+    throw new Error(`Could not find a field id in previousPath (${args.previousPath.join(".")}) and/or newPath (${args.newPath.join(".")}), which should not be possible.`);
+  }
+  const customType = shallowCloneIfObject(args.customType);
+  if (typeof customType === "string") {
+    return customType;
+  }
+  const matchedCustomTypeId = customType.id === previousPath.customTypeId;
+  return {
+    ...customType,
+    fields: customType.fields.map((fieldArg) => {
+      const customTypeField = shallowCloneIfObject(fieldArg);
+      if (typeof customTypeField === "string") {
+        if (matchedCustomTypeId && customTypeField === previousPath.fieldId && customTypeField !== newPath.fieldId) {
+          return newPath.fieldId;
+        }
+        return customTypeField;
+      }
+      if (matchedCustomTypeId && customTypeField.id === previousPath.fieldId && customTypeField.id !== newPath.fieldId) {
+        customTypeField.id = newPath.fieldId;
+      }
+      if ("fields" in customTypeField) {
+        if (!previousPath.groupId && !newPath.groupId && customTypeField.id === previousPath.fieldId && customTypeField.id !== newPath.fieldId) {
+          return newPath.fieldId;
+        }
+        const matchedGroupId = customTypeField.id === previousPath.groupId;
+        if (previousPath.groupId && newPath.groupId && matchedGroupId && customTypeField.id !== newPath.groupId) {
+          customTypeField.id = newPath.groupId;
+        }
+        return {
+          ...customTypeField,
+          fields: customTypeField.fields.map((groupFieldArg) => {
+            const groupField = shallowCloneIfObject(groupFieldArg);
+            if (typeof groupField === "string") {
+              if (matchedGroupId && groupField === previousPath.fieldId && groupField !== newPath.fieldId) {
+                return newPath.fieldId;
+              }
+              return groupField;
+            }
+            return {
+              ...groupField,
+              fields: updateContentRelationshipFields({
+                customtypes: groupField.customtypes,
+                previousPath,
+                newPath
+              })
+            };
+          })
+        };
+      }
+      return {
+        ...customTypeField,
+        customtypes: updateContentRelationshipFields({
+          customtypes: customTypeField.customtypes,
+          previousPath,
+          newPath
+        })
+      };
+    })
+  };
+}
+function updateContentRelationshipFields(args) {
+  const { customtypes: customtypes2, previousPath, newPath } = args;
+  return customtypes2.map((nestedCtArg) => {
+    const nestedCt = shallowCloneIfObject(nestedCtArg);
+    if (typeof nestedCt === "string" || // Since we are entering a new custom type, if the previous id
+    // doesn't match, we can return early, because it's not the
+    // custom type we are looking for.
+    nestedCt.id !== previousPath.customTypeId) {
+      return nestedCt;
+    }
+    return {
+      ...nestedCt,
+      fields: nestedCt.fields.map((nestedCtFieldArg) => {
+        const nestedCtField = shallowCloneIfObject(nestedCtFieldArg);
+        if (typeof nestedCtField === "string") {
+          if (nestedCtField === previousPath.fieldId && nestedCtField !== newPath.fieldId) {
+            return newPath.fieldId;
+          }
+          return nestedCtField;
+        }
+        if (nestedCtField.id === previousPath.fieldId && nestedCtField.id !== newPath.fieldId) {
+          nestedCtField.id = newPath.fieldId;
+        }
+        if (!previousPath.groupId || !newPath.groupId || nestedCtField.id !== previousPath.groupId) {
+          return nestedCtField;
+        }
+        if (nestedCtField.id !== newPath.groupId) {
+          nestedCtField.id = newPath.groupId;
+        }
+        return {
+          ...nestedCtField,
+          fields: nestedCtField.fields.map((nestedCtGroupFieldId) => {
+            if (nestedCtGroupFieldId === previousPath.fieldId && nestedCtGroupFieldId !== newPath.fieldId) {
+              return newPath.fieldId;
+            }
+            return nestedCtGroupFieldId;
+          })
+        };
+      })
+    };
+  });
+}
+function updateFieldContentRelationships(args) {
+  var _a, _b;
+  const { field, ...updateMeta } = args;
+  if (field.type !== "Link" || ((_a = field.config) == null ? void 0 : _a.select) !== "document" || !((_b = field.config) == null ? void 0 : _b.customtypes)) {
+    return field;
+  }
+  const newCustomTypes = field.config.customtypes.map((customType) => {
+    return updateCRCustomType({ ...updateMeta, customType });
+  });
+  return {
+    ...field,
+    config: { ...field.config, customtypes: newCustomTypes }
+  };
+}
+function updateCustomTypeContentRelationships(args) {
+  const { models, previousPath, newPath, onUpdate } = args;
+  for (const { model: customType } of models) {
+    const updatedCustomType = customtypes.traverseCustomType({
+      customType,
+      onField: ({ field }) => {
+        return updateFieldContentRelationships({
+          field,
+          previousPath,
+          newPath
+        });
+      }
+    });
+    if (!isEqualModel(customType, updatedCustomType)) {
+      onUpdate({ model: updatedCustomType, previousModel: customType });
+    }
+  }
+}
+function updateSharedSliceContentRelationships(args) {
+  const { models, previousPath, newPath, onUpdate } = args;
+  for (const { model: slice } of models) {
+    const updateSlice = customtypes.traverseSharedSlice({
+      path: [],
+      slice,
+      onField: ({ field }) => {
+        return updateFieldContentRelationships({
+          field,
+          previousPath,
+          newPath
+        });
+      }
+    });
+    if (!isEqualModel(slice, updateSlice)) {
+      onUpdate({ model: updateSlice, previousModel: slice });
+    }
+  }
+}
+function getPathIds(path2) {
+  if (path2.length < 2) {
+    throw new Error(`Unexpected path length ${path2.length}. Expected at least 2 segments (got: ${path2.join(".")}).`);
+  }
+  const [customTypeId, groupOrFieldId, fieldId] = path2;
+  return {
+    customTypeId,
+    /**
+     * Id of a changed group. If it's defined, it means that a group or a field
+     * inside a group had its API ID renamed. It's defined when the path has a
+     * third element (e.g. `["customtypeA", "groupA", "fieldA"]`).
+     */
+    groupId: fieldId ? groupOrFieldId : void 0,
+    fieldId: fieldId || groupOrFieldId
+  };
+}
+function isEqualModel(modelA, modelB) {
+  return JSON.stringify(modelA) === JSON.stringify(modelB);
+}
+function shallowCloneIfObject(value) {
+  if (typeof value === "object") {
+    return { ...value };
+  }
+  return value;
+}
+exports.CustomTypesManager = CustomTypesManager;
+exports.updateCustomTypeContentRelationships = updateCustomTypeContentRelationships;
+exports.updateSharedSliceContentRelationships = updateSharedSliceContentRelationships;
+//# sourceMappingURL=CustomTypesManager.cjs.map
